<div class="_page _node"><h1 id="stream_stream">Stream</h1> <pre class="api_stability_2">Stability: 2 - Unstable</pre>
<p>A stream is an abstract interface implemented by various objects in Node. For example a <a href="http#http_http_incomingmessage">request to an HTTP server</a> is a stream, as is <a href="process#process_process_stdout">stdout</a>. Streams are readable, writable, or both. All streams are instances of <a href="events#events_class_events_eventemitter">EventEmitter</a> </p> <p>You can load the Stream base classes by doing <code>require('stream')</code>. There are base classes provided for <a href="#stream_class_stream_readable">Readable</a> streams, <a href="#stream_class_stream_writable">Writable</a> streams, <a href="#stream_class_stream_duplex">Duplex</a> streams, and <a href="#stream_class_stream_transform">Transform</a> streams. </p> <p>This document is split up into 3 sections. The first explains the parts of the API that you need to be aware of to use streams in your programs. If you never implement a streaming API yourself, you can stop there. </p> <p>The second section explains the parts of the API that you need to use if you implement your own custom streams yourself. The API is designed to make this easy for you to do. </p> <p>The third section goes into more depth about how streams work, including some of the internal mechanisms and functions that you should probably not modify unless you definitely know what you are doing. </p> <h2 id="stream_api_for_stream_consumers">API for Stream Consumers</h2>  <p>Streams can be either <a href="#stream_class_stream_readable">Readable</a>, <a href="#stream_class_stream_writable">Writable</a>, or both (<a href="#stream_class_stream_duplex">Duplex</a>). </p> <p>All streams are EventEmitters, but they also have other custom methods and properties depending on whether they are Readable, Writable, or Duplex. </p> <p>If a stream is both Readable and Writable, then it implements all of the methods and events below. So, a <a href="#stream_class_stream_duplex">Duplex</a> or <a href="#stream_class_stream_transform">Transform</a> stream is fully described by this API, though their implementation may be somewhat different. </p> <p>It is not necessary to implement Stream interfaces in order to consume streams in your programs. If you <strong>are</strong> implementing streaming interfaces in your own program, please also refer to <a href="#stream_api_for_stream_implementors">API for Stream Implementors</a> below. </p> <p>Almost all Node programs, no matter how simple, use Streams in some way. Here is an example of using Streams in a Node program: </p> <pre class=" language-javascript"><code class="javascript  language-javascript"><span class="token keyword">var</span> http <span class="token operator">=</span> <span class="token function">require<span class="token punctuation">(</span></span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer<span class="token punctuation">(</span></span><span class="token keyword">function</span> <span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token comment" spellcheck="true"> // req is an http.IncomingMessage, which is a Readable Stream
</span> <span class="token comment" spellcheck="true"> // res is an http.ServerResponse, which is a Writable Stream
</span>
  <span class="token keyword">var</span> body <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>
 <span class="token comment" spellcheck="true"> // we want to get the data as utf8 strings
</span> <span class="token comment" spellcheck="true"> // If you don't set an encoding, then you'll get Buffer objects
</span>  req<span class="token punctuation">.</span><span class="token function">setEncoding<span class="token punctuation">(</span></span><span class="token string">'utf8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token comment" spellcheck="true"> // Readable streams emit 'data' events once a listener is added
</span>  req<span class="token punctuation">.</span><span class="token function">on<span class="token punctuation">(</span></span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>chunk<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    body <span class="token operator">+</span><span class="token operator">=</span> chunk<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

 <span class="token comment" spellcheck="true"> // the end event tells you that you have entire body
</span>  req<span class="token punctuation">.</span><span class="token function">on<span class="token punctuation">(</span></span><span class="token string">'end'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> data <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse<span class="token punctuation">(</span></span>body<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">er</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment" spellcheck="true"> // uh oh!  bad json!
</span>      res<span class="token punctuation">.</span>statusCode <span class="token operator">=</span> <span class="token number">400</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> res<span class="token punctuation">.</span><span class="token function">end<span class="token punctuation">(</span></span><span class="token string">'error: '</span> <span class="token operator">+</span> er<span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

   <span class="token comment" spellcheck="true"> // write back something interesting to the user:
</span>    res<span class="token punctuation">.</span><span class="token function">write<span class="token punctuation">(</span></span><span class="token keyword">typeof</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    res<span class="token punctuation">.</span><span class="token function">end<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

server<span class="token punctuation">.</span><span class="token function">listen<span class="token punctuation">(</span></span><span class="token number">1337</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">
// $ curl localhost:1337 -d '{}'
</span><span class="token comment" spellcheck="true">// object
</span><span class="token comment" spellcheck="true">// $ curl localhost:1337 -d '"foo"'
</span><span class="token comment" spellcheck="true">// string
</span><span class="token comment" spellcheck="true">// $ curl localhost:1337 -d 'not json'
</span><span class="token comment" spellcheck="true">// error: Unexpected token o</span></code></pre> <h3 id="stream_class_stream_readable">Class: stream.Readable</h3>  <p>The Readable stream interface is the abstraction for a <em>source</em> of data that you are reading from. In other words, data comes <em>out</em> of a Readable stream. </p> <p>A Readable stream will not start emitting data until you indicate that you are ready to receive it. </p> <p>Readable streams have two "modes": a <strong>flowing mode</strong> and a <strong>non-flowing mode</strong>. When in flowing mode, data is read from the underlying system and provided to your program as fast as possible. In non-flowing mode, you must explicitly call <code>stream.read()</code> to get chunks of data out. </p> <p>Examples of readable streams include: </p> <ul>
<li><a href="http#http_http_incomingmessage">http responses, on the client</a></li> <li><a href="http#http_http_incomingmessage">http requests, on the server</a></li> <li><a href="fs#fs_class_fs_readstream">fs read streams</a></li> <li><a href="zlib">zlib streams</a></li> <li><a href="crypto">crypto streams</a></li> <li><a href="net#net_class_net_socket">tcp sockets</a></li> <li><a href="child_process#child_process_child_stdout">child process stdout and stderr</a></li> <li><a href="process#process_process_stdin">process.stdin</a></li> </ul>
<h4 id="stream_event_readable">Event: 'readable'</h4> <p>When a chunk of data can be read from the stream, it will emit a <code>'readable'</code> event. </p> <p>In some cases, listening for a <code>'readable'</code> event will cause some data to be read into the internal buffer from the underlying system, if it hadn't already. </p> <pre class=" language-javascript"><code class="javascript  language-javascript"><span class="token keyword">var</span> readable <span class="token operator">=</span> <span class="token function">getReadableStreamSomehow<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
readable<span class="token punctuation">.</span><span class="token function">on<span class="token punctuation">(</span></span><span class="token string">'readable'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token comment" spellcheck="true"> // there is some data to read now
</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre> <p>Once the internal buffer is drained, a <code>readable</code> event will fire again when more data is available. </p> <h4 id="stream_event_data">Event: 'data'</h4> <div class="signature"><ul>
<li>
<code>chunk</code> <span class="type">Buffer | String</span> The chunk of data.</li> </ul></div> <p>If you attach a <code>data</code> event listener, then it will switch the stream into flowing mode, and data will be passed to your handler as soon as it is available. </p> <p>If you just want to get all the data out of the stream as fast as possible, this is the best way to do so. </p> <pre class=" language-javascript"><code class="javascript  language-javascript"><span class="token keyword">var</span> readable <span class="token operator">=</span> <span class="token function">getReadableStreamSomehow<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
readable<span class="token punctuation">.</span><span class="token function">on<span class="token punctuation">(</span></span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>chunk<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span><span class="token string">'got %d bytes of data'</span><span class="token punctuation">,</span> chunk<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre> <h4 id="stream_event_end">Event: 'end'</h4> <p>This event fires when no more data will be provided. </p> <p>Note that the <code>end</code> event <strong>will not fire</strong> unless the data is completely consumed. This can be done by switching into flowing mode, or by calling <code>read()</code> repeatedly until you get to the end. </p> <pre class=" language-javascript"><code class="javascript  language-javascript"><span class="token keyword">var</span> readable <span class="token operator">=</span> <span class="token function">getReadableStreamSomehow<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
readable<span class="token punctuation">.</span><span class="token function">on<span class="token punctuation">(</span></span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>chunk<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span><span class="token string">'got %d bytes of data'</span><span class="token punctuation">,</span> chunk<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
readable<span class="token punctuation">.</span><span class="token function">on<span class="token punctuation">(</span></span><span class="token string">'end'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span><span class="token string">'there will be no more data.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> <h4 id="stream_event_close" class="">Event: 'close'</h4> <p>Emitted when the underlying resource (for example, the backing file descriptor) has been closed. Not all streams will emit this. </p> <h4 id="stream_event_error">Event: 'error'</h4> <p>Emitted if there was an error receiving data. </p> <h4 id="stream_readable_read_size">readable.read([size])</h4> <div class="signature"><ul>
<li>
<code>size</code> <span class="type">Number</span> Optional argument to specify how much data to read.</li> <li>Return <span class="type">String | Buffer | null</span>
</li> </ul></div> <p>The <code>read()</code> method pulls some data out of the internal buffer and returns it. If there is no data available, then it will return <code>null</code>. </p> <p>If you pass in a <code>size</code> argument, then it will return that many bytes. If <code>size</code> bytes are not available, then it will return <code>null</code>. </p> <p>If you do not specify a <code>size</code> argument, then it will return all the data in the internal buffer. </p> <p>This method should only be called in non-flowing mode. In flowing-mode, this method is called automatically until the internal buffer is drained. </p> <pre class=" language-javascript"><code class="javascript  language-javascript"><span class="token keyword">var</span> readable <span class="token operator">=</span> <span class="token function">getReadableStreamSomehow<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
readable<span class="token punctuation">.</span><span class="token function">on<span class="token punctuation">(</span></span><span class="token string">'readable'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> chunk<span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">!</span><span class="token operator">==</span> <span class="token punctuation">(</span>chunk <span class="token operator">=</span> readable<span class="token punctuation">.</span><span class="token function">read<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span><span class="token string">'got %d bytes of data'</span><span class="token punctuation">,</span> chunk<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> <h4 id="stream_readable_setencoding_encoding">readable.setEncoding(encoding)</h4> <div class="signature"><ul>
<li>
<code>encoding</code> <span class="type">String</span> The encoding to use.</li> </ul></div> <p>Call this function to cause the stream to return strings of the specified encoding instead of Buffer objects. For example, if you do <code>readable.setEncoding('utf8')</code>, then the output data will be interpreted as UTF-8 data, and returned as strings. If you do <code>readable.setEncoding('hex')</code>, then the data will be encoded in hexadecimal string format. </p> <p>This properly handles multi-byte characters that would otherwise be potentially mangled if you simply pulled the Buffers directly and called <code>buf.toString(encoding)</code> on them. If you want to read the data as strings, always use this method. </p> <pre class=" language-javascript"><code class="javascript  language-javascript"><span class="token keyword">var</span> readable <span class="token operator">=</span> <span class="token function">getReadableStreamSomehow<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
readable<span class="token punctuation">.</span><span class="token function">setEncoding<span class="token punctuation">(</span></span><span class="token string">'utf8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
readable<span class="token punctuation">.</span><span class="token function">on<span class="token punctuation">(</span></span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>chunk<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  assert<span class="token punctuation">.</span><span class="token function">equal<span class="token punctuation">(</span></span><span class="token keyword">typeof</span> chunk<span class="token punctuation">,</span> <span class="token string">'string'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span><span class="token string">'got %d characters of string data'</span><span class="token punctuation">,</span> chunk<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre> <h4 id="stream_readable_resume">readable.resume()</h4> <p>This method will cause the readable stream to resume emitting <code>data</code> events. </p> <p>This method will switch the stream into flowing-mode. If you do <em>not</em> want to consume the data from a stream, but you <em>do</em> want to get to its <code>end</code> event, you can call <code>readable.resume()</code> to open the flow of data. </p> <pre class=" language-javascript"><code class="javascript  language-javascript"><span class="token keyword">var</span> readable <span class="token operator">=</span> <span class="token function">getReadableStreamSomehow<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
readable<span class="token punctuation">.</span><span class="token function">resume<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
readable<span class="token punctuation">.</span><span class="token function">on<span class="token punctuation">(</span></span><span class="token string">'end'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>chunk<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span><span class="token string">'got to the end, but did not read anything'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre> <h4 id="stream_readable_pause">readable.pause()</h4> <p>This method will cause a stream in flowing-mode to stop emitting <code>data</code> events. Any data that becomes available will remain in the internal buffer. </p> <p>This method is only relevant in flowing mode. When called on a non-flowing stream, it will switch into flowing mode, but remain paused. </p> <pre class=" language-javascript"><code class="javascript  language-javascript"><span class="token keyword">var</span> readable <span class="token operator">=</span> <span class="token function">getReadableStreamSomehow<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
readable<span class="token punctuation">.</span><span class="token function">on<span class="token punctuation">(</span></span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>chunk<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span><span class="token string">'got %d bytes of data'</span><span class="token punctuation">,</span> chunk<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
  readable<span class="token punctuation">.</span><span class="token function">pause<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span><span class="token string">'there will be no more data for 1 second'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">setTimeout<span class="token punctuation">(</span></span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span><span class="token string">'now data will start flowing again'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    readable<span class="token punctuation">.</span><span class="token function">resume<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre> <h4 id="stream_readable_pipe_destination_options">readable.pipe(destination, [options])</h4> <div class="signature"><ul>
<li>
<code>destination</code> <span class="type"><a href="#stream_class_stream_writable">Writable</a> Stream</span> The destination for writing data</li> <li>
<code>options</code> <span class="type">Object</span> Pipe options<ul>
<li>
<code>end</code> <span class="type">Boolean</span> End the writer when the reader ends. Default = <code>true</code>
</li> </ul>
</li> </ul></div> <p>This method pulls all the data out of a readable stream, and writes it to the supplied destination, automatically managing the flow so that the destination is not overwhelmed by a fast readable stream. </p> <p>Multiple destinations can be piped to safely. </p> <pre class=" language-javascript"><code class="javascript  language-javascript"><span class="token keyword">var</span> readable <span class="token operator">=</span> <span class="token function">getReadableStreamSomehow<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> writable <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createWriteStream<span class="token punctuation">(</span></span><span class="token string">'file.txt'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">
// All the data from readable goes into 'file.txt'
</span>readable<span class="token punctuation">.</span><span class="token function">pipe<span class="token punctuation">(</span></span>writable<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> <p>This function returns the destination stream, so you can set up pipe chains like so: </p> <pre class=" language-javascript"><code class="javascript  language-javascript"><span class="token keyword">var</span> r <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createReadStream<span class="token punctuation">(</span></span><span class="token string">'file.txt'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> z <span class="token operator">=</span> zlib<span class="token punctuation">.</span><span class="token function">createGzip<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> w <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createWriteStream<span class="token punctuation">(</span></span><span class="token string">'file.txt.gz'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
r<span class="token punctuation">.</span><span class="token function">pipe<span class="token punctuation">(</span></span>z<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pipe<span class="token punctuation">(</span></span>w<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> <p>For example, emulating the Unix <code>cat</code> command: </p> <pre class=" language-javascript"><code class="javascript  language-javascript">process<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span><span class="token function">pipe<span class="token punctuation">(</span></span>process<span class="token punctuation">.</span>stdout<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> <p>By default <a href="#stream_writable_end_chunk_encoding_callback"><code>end()</code></a> is called on the destination when the source stream emits <code>end</code>, so that <code>destination</code> is no longer writable. Pass <code>{ end:
false }</code> as <code>options</code> to keep the destination stream open. </p> <p>This keeps <code>writer</code> open so that "Goodbye" can be written at the end. </p> <pre class=" language-javascript"><code class="javascript  language-javascript">reader<span class="token punctuation">.</span><span class="token function">pipe<span class="token punctuation">(</span></span>writer<span class="token punctuation">,</span> <span class="token punctuation">{</span> end<span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
reader<span class="token punctuation">.</span><span class="token function">on<span class="token punctuation">(</span></span><span class="token string">'end'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  writer<span class="token punctuation">.</span><span class="token function">end<span class="token punctuation">(</span></span><span class="token string">'Goodbye\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> <p>Note that <code>process.stderr</code> and <code>process.stdout</code> are never closed until the process exits, regardless of the specified options. </p> <h4 id="stream_readable_unpipe_destination">readable.unpipe([destination])</h4> <div class="signature"><ul>
<li>
<code>destination</code> <span class="type"><a href="#stream_class_stream_writable">Writable</a> Stream</span> Optional specific stream to unpipe</li> </ul></div> <p>This method will remove the hooks set up for a previous <code>pipe()</code> call. </p> <p>If the destination is not specified, then all pipes are removed. </p> <p>If the destination is specified, but no pipe is set up for it, then this is a no-op. </p> <pre class=" language-javascript"><code class="javascript  language-javascript"><span class="token keyword">var</span> readable <span class="token operator">=</span> <span class="token function">getReadableStreamSomehow<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> writable <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createWriteStream<span class="token punctuation">(</span></span><span class="token string">'file.txt'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">
// All the data from readable goes into 'file.txt',
</span><span class="token comment" spellcheck="true">// but only for the first second
</span>readable<span class="token punctuation">.</span><span class="token function">pipe<span class="token punctuation">(</span></span>writable<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setTimeout<span class="token punctuation">(</span></span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span><span class="token string">'stop writing to file.txt'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  readable<span class="token punctuation">.</span><span class="token function">unpipe<span class="token punctuation">(</span></span>writable<span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span><span class="token string">'manually close the file stream'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  writable<span class="token punctuation">.</span><span class="token function">end<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> <h4 id="stream_readable_unshift_chunk">readable.unshift(chunk)</h4> <div class="signature"><ul>
<li>
<code>chunk</code> <span class="type">Buffer | String</span> Chunk of data to unshift onto the read queue</li> </ul></div> <p>This is useful in certain cases where a stream is being consumed by a parser, which needs to "un-consume" some data that it has optimistically pulled out of the source, so that the stream can be passed on to some other party. </p> <p>If you find that you must often call <code>stream.unshift(chunk)</code> in your programs, consider implementing a <a href="#stream_class_stream_transform">Transform</a> stream instead. (See API for Stream Implementors, below.) </p> <pre class=" language-javascript"><code class="javascript  language-javascript"><span class="token comment" spellcheck="true">// Pull off a header delimited by \n\n
</span><span class="token comment" spellcheck="true">// use unshift() if we get too much
</span><span class="token comment" spellcheck="true">// Call the callback with (error, header, stream)
</span><span class="token keyword">var</span> StringDecoder <span class="token operator">=</span> <span class="token function">require<span class="token punctuation">(</span></span><span class="token string">'string_decoder'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>StringDecoder<span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">parseHeader<span class="token punctuation">(</span></span>stream<span class="token punctuation">,</span> callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  stream<span class="token punctuation">.</span><span class="token function">on<span class="token punctuation">(</span></span><span class="token string">'error'</span><span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
  stream<span class="token punctuation">.</span><span class="token function">on<span class="token punctuation">(</span></span><span class="token string">'readable'</span><span class="token punctuation">,</span> onReadable<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> decoder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringDecoder</span><span class="token punctuation">(</span><span class="token string">'utf8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> header <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">onReadable<span class="token punctuation">(</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> chunk<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">!</span><span class="token operator">==</span> <span class="token punctuation">(</span>chunk <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">read<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> str <span class="token operator">=</span> decoder<span class="token punctuation">.</span><span class="token function">write<span class="token punctuation">(</span></span>chunk<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">match<span class="token punctuation">(</span></span><span class="token regex">/\n\n/</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment" spellcheck="true"> // found the header boundary
</span>        <span class="token keyword">var</span> split <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">split<span class="token punctuation">(</span></span><span class="token regex">/\n\n/</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        header <span class="token operator">+</span><span class="token operator">=</span> split<span class="token punctuation">.</span><span class="token function">shift<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">var</span> remaining <span class="token operator">=</span> split<span class="token punctuation">.</span><span class="token function">join<span class="token punctuation">(</span></span><span class="token string">'\n\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">var</span> buf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Buffer</span><span class="token punctuation">(</span>remaining<span class="token punctuation">,</span> <span class="token string">'utf8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>buf<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
          stream<span class="token punctuation">.</span><span class="token function">unshift<span class="token punctuation">(</span></span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
        stream<span class="token punctuation">.</span><span class="token function">removeListener<span class="token punctuation">(</span></span><span class="token string">'error'</span><span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
        stream<span class="token punctuation">.</span><span class="token function">removeListener<span class="token punctuation">(</span></span><span class="token string">'readable'</span><span class="token punctuation">,</span> onReadable<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token comment" spellcheck="true"> // now the body of the message can be read from the stream.
</span>        <span class="token function">callback<span class="token punctuation">(</span></span><span class="token keyword">null</span><span class="token punctuation">,</span> header<span class="token punctuation">,</span> stream<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
       <span class="token comment" spellcheck="true"> // still reading the header.
</span>        header <span class="token operator">+</span><span class="token operator">=</span> str<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre> <h4 id="stream_readable_wrap_stream">readable.wrap(stream)</h4> <div class="signature"><ul>
<li>
<code>stream</code> <span class="type">Stream</span> An "old style" readable stream</li> </ul></div> <p>Versions of Node prior to v0.10 had streams that did not implement the entire Streams API as it is today. (See "Compatibility" below for more information.) </p> <p>If you are using an older Node library that emits <code>'data'</code> events and has a <code>pause()</code> method that is advisory only, then you can use the <code>wrap()</code> method to create a <a href="#stream_class_stream_readable">Readable</a> stream that uses the old stream as its data source. </p> <p>You will very rarely ever need to call this function, but it exists as a convenience for interacting with old Node programs and libraries. </p> <p>For example: </p> <pre class=" language-javascript"><code class="javascript  language-javascript"><span class="token keyword">var</span> OldReader <span class="token operator">=</span> <span class="token function">require<span class="token punctuation">(</span></span><span class="token string">'./old-api-module.js'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>OldReader<span class="token punctuation">;</span>
<span class="token keyword">var</span> oreader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OldReader</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> Readable <span class="token operator">=</span> <span class="token function">require<span class="token punctuation">(</span></span><span class="token string">'stream'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Readable<span class="token punctuation">;</span>
<span class="token keyword">var</span> myReader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Readable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">wrap<span class="token punctuation">(</span></span>oreader<span class="token punctuation">)</span><span class="token punctuation">;</span>

myReader<span class="token punctuation">.</span><span class="token function">on<span class="token punctuation">(</span></span><span class="token string">'readable'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  myReader<span class="token punctuation">.</span><span class="token function">read<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"> // etc.
</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> <h3 id="stream_class_stream_writable">Class: stream.Writable</h3>  <p>The Writable stream interface is an abstraction for a <em>destination</em> that you are writing data <em>to</em>. </p> <p>Examples of writable streams include: </p> <ul>
<li><a href="http#http_class_http_clientrequest">http requests, on the client</a></li> <li><a href="http#http_class_http_serverresponse">http responses, on the server</a></li> <li><a href="fs#fs_class_fs_writestream">fs write streams</a></li> <li><a href="zlib">zlib streams</a></li> <li><a href="crypto">crypto streams</a></li> <li><a href="net#net_class_net_socket">tcp sockets</a></li> <li><a href="child_process#child_process_child_stdin">child process stdin</a></li> <li>
<a href="process#process_process_stdout">process.stdout</a>, <a href="process#process_process_stderr">process.stderr</a>
</li> </ul>
<h4 id="stream_writable_write_chunk_encoding_callback">writable.write(chunk, [encoding], [callback])</h4> <div class="signature"><ul>
<li>
<code>chunk</code> <span class="type">String | Buffer</span> The data to write</li> <li>
<code>encoding</code> <span class="type">String</span> The encoding, if <code>chunk</code> is a String</li> <li>
<code>callback</code> <span class="type">Function</span> Callback for when this chunk of data is flushed</li> <li>Returns: <span class="type">Boolean</span> True if the data was handled completely.</li> </ul></div> <p>This method writes some data to the underlying system, and calls the supplied callback once the data has been fully handled. </p> <p>The return value indicates if you should continue writing right now. If the data had to be buffered internally, then it will return <code>false</code>. Otherwise, it will return <code>true</code>. </p> <p>This return value is strictly advisory. You MAY continue to write, even if it returns <code>false</code>. However, writes will be buffered in memory, so it is best not to do this excessively. Instead, wait for the <code>drain</code> event before writing more data. </p> <h4 id="stream_event_drain">Event: 'drain'</h4> <p>If a <a href="#stream_writable_write_chunk_encoding_callback"><code>writable.write(chunk)</code></a> call returns false, then the <code>drain</code> event will indicate when it is appropriate to begin writing more data to the stream. </p> <pre class=" language-javascript"><code class="javascript  language-javascript"><span class="token comment" spellcheck="true">// Write the data to the supplied writable stream 1MM times.
</span><span class="token comment" spellcheck="true">// Be attentive to back-pressure.
</span><span class="token keyword">function</span> <span class="token function">writeOneMillionTimes<span class="token punctuation">(</span></span>writer<span class="token punctuation">,</span> data<span class="token punctuation">,</span> encoding<span class="token punctuation">,</span> callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1000000</span><span class="token punctuation">;</span>
  <span class="token function">write<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">write<span class="token punctuation">(</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> ok <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
      i <span class="token operator">-</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment" spellcheck="true"> // last time!
</span>        writer<span class="token punctuation">.</span><span class="token function">write<span class="token punctuation">(</span></span>data<span class="token punctuation">,</span> encoding<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
       <span class="token comment" spellcheck="true"> // see if we should continue, or wait
</span>       <span class="token comment" spellcheck="true"> // don't pass the callback, because we're not done yet.
</span>        ok <span class="token operator">=</span> writer<span class="token punctuation">.</span><span class="token function">write<span class="token punctuation">(</span></span>data<span class="token punctuation">,</span> encoding<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> ok<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment" spellcheck="true"> // had to stop early!
</span>     <span class="token comment" spellcheck="true"> // write some more once it drains
</span>      writer<span class="token punctuation">.</span><span class="token function">once<span class="token punctuation">(</span></span><span class="token string">'drain'</span><span class="token punctuation">,</span> write<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre> <h4 id="stream_writable_end_chunk_encoding_callback">writable.end([chunk], [encoding], [callback])</h4> <div class="signature"><ul>
<li>
<code>chunk</code> <span class="type">String | Buffer</span> Optional data to write</li> <li>
<code>encoding</code> <span class="type">String</span> The encoding, if <code>chunk</code> is a String</li> <li>
<code>callback</code> <span class="type">Function</span> Optional callback for when the stream is finished</li> </ul></div> <p>Call this method when no more data will be written to the stream. If supplied, the callback is attached as a listener on the <code>finish</code> event. </p> <p>Calling <a href="#stream_writable_write_chunk_encoding_callback"><code>write()</code></a> after calling <a href="#stream_writable_end_chunk_encoding_callback"><code>end()</code></a> will raise an error. </p> <pre class=" language-javascript"><code class="javascript  language-javascript"><span class="token comment" spellcheck="true">// write 'hello, ' and then end with 'world!'
</span>http<span class="token punctuation">.</span><span class="token function">createServer<span class="token punctuation">(</span></span><span class="token keyword">function</span> <span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  res<span class="token punctuation">.</span><span class="token function">write<span class="token punctuation">(</span></span><span class="token string">'hello, '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  res<span class="token punctuation">.</span><span class="token function">end<span class="token punctuation">(</span></span><span class="token string">'world!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment" spellcheck="true"> // writing more now is not allowed!
</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> <h4 id="stream_event_finish">Event: 'finish'</h4> <p>When the <a href="#stream_writable_end_chunk_encoding_callback"><code>end()</code></a> method has been called, and all data has been flushed to the underlying system, this event is emitted. </p> <pre class=" language-javascript"><code class="javascript  language-javascript"><span class="token keyword">var</span> writer <span class="token operator">=</span> <span class="token function">getWritableStreamSomehow<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  writer<span class="token punctuation">.</span><span class="token function">write<span class="token punctuation">(</span></span><span class="token string">'hello, #'</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">'!\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
writer<span class="token punctuation">.</span><span class="token function">end<span class="token punctuation">(</span></span><span class="token string">'this is the end\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
writer<span class="token punctuation">.</span><span class="token function">on<span class="token punctuation">(</span></span><span class="token string">'finish'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">error<span class="token punctuation">(</span></span><span class="token string">'all writes are now complete.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> <h4 id="stream_event_pipe">Event: 'pipe'</h4> <div class="signature"><ul>
<li>
<code>src</code> <span class="type"><a href="#stream_class_stream_readable">Readable</a> Stream</span> source stream that is piping to this writable</li> </ul></div> <p>This is emitted whenever the <code>pipe()</code> method is called on a readable stream, adding this writable to its set of destinations. </p> <pre class=" language-javascript"><code class="javascript  language-javascript"><span class="token keyword">var</span> writer <span class="token operator">=</span> <span class="token function">getWritableStreamSomehow<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> reader <span class="token operator">=</span> <span class="token function">getReadableStreamSomehow<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
writer<span class="token punctuation">.</span><span class="token function">on<span class="token punctuation">(</span></span><span class="token string">'pipe'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">error<span class="token punctuation">(</span></span><span class="token string">'something is piping into the writer'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  assert<span class="token punctuation">.</span><span class="token function">equal<span class="token punctuation">(</span></span>src<span class="token punctuation">,</span> reader<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
reader<span class="token punctuation">.</span><span class="token function">pipe<span class="token punctuation">(</span></span>writer<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> <h4 id="stream_event_unpipe">Event: 'unpipe'</h4> <div class="signature"><ul>
<li>
<code>src</code> <span class="type"><a href="#stream_class_stream_readable">Readable</a> Stream</span> The source stream that <a href="#stream_readable_unpipe_destination">unpiped</a> this writable</li> </ul></div> <p>This is emitted whenever the <a href="#stream_readable_unpipe_destination"><code>unpipe()</code></a> method is called on a readable stream, removing this writable from its set of destinations. </p> <pre class=" language-javascript"><code class="javascript  language-javascript"><span class="token keyword">var</span> writer <span class="token operator">=</span> <span class="token function">getWritableStreamSomehow<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> reader <span class="token operator">=</span> <span class="token function">getReadableStreamSomehow<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
writer<span class="token punctuation">.</span><span class="token function">on<span class="token punctuation">(</span></span><span class="token string">'unpipe'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">error<span class="token punctuation">(</span></span><span class="token string">'something has stopped piping into the writer'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  assert<span class="token punctuation">.</span><span class="token function">equal<span class="token punctuation">(</span></span>src<span class="token punctuation">,</span> reader<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
reader<span class="token punctuation">.</span><span class="token function">pipe<span class="token punctuation">(</span></span>writer<span class="token punctuation">)</span><span class="token punctuation">;</span>
reader<span class="token punctuation">.</span><span class="token function">unpipe<span class="token punctuation">(</span></span>writer<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> <h4 id="stream_event_error_1">Event: 'error'</h4> <p>Emitted if there was an error when writing or piping data. </p> <h3 id="stream_class_stream_duplex">Class: stream.Duplex</h3> <p>Duplex streams are streams that implement both the <a href="#stream_class_stream_readable">Readable</a> and <a href="#stream_class_stream_writable">Writable</a> interfaces. See above for usage. </p> <p>Examples of Duplex streams include: </p> <ul>
<li><a href="net#net_class_net_socket">tcp sockets</a></li> <li><a href="zlib">zlib streams</a></li> <li><a href="crypto">crypto streams</a></li> </ul>
<h3 id="stream_class_stream_transform">Class: stream.Transform</h3> <p>Transform streams are <a href="#stream_class_stream_duplex">Duplex</a> streams where the output is in some way computed from the input. They implement both the <a href="#stream_class_stream_readable">Readable</a> and <a href="#stream_class_stream_writable">Writable</a> interfaces. See above for usage. </p> <p>Examples of Transform streams include: </p> <ul>
<li><a href="zlib">zlib streams</a></li> <li><a href="crypto">crypto streams</a></li> </ul>
<h2 id="stream_api_for_stream_implementors">API for Stream Implementors</h2>  <p>To implement any sort of stream, the pattern is the same: </p> <ol>
<li>Extend the appropriate parent class in your own subclass. (The <a href="util#util_util_inherits_constructor_superconstructor"><code>util.inherits</code></a> method is particularly helpful for this.)</li> <li>Call the appropriate parent class constructor in your constructor, to be sure that the internal mechanisms are set up properly.</li> <li>Implement one or more specific methods, as detailed below.</li> </ol>
<p>The class to extend and the method(s) to implement depend on the sort of stream class you are writing: </p> <table>
<thead><tr>
<th> <p>Use-case</p> </th> <th> <p>Class</p> </th> <th> <p>Method(s) to implement</p> </th> </tr></thead>
<tbody><tr>
<td> <p>Reading only</p> </td> <td> <p><a href="#stream_class_stream_readable_1">Readable</a></p> </td> <td> <p><code><a href="#stream_readable_read_size_1">_read</a></code></p> </td> </tr>
<tr>
<td> <p>Writing only</p> </td> <td> <p><a href="#stream_class_stream_writable_1">Writable</a></p> </td> <td> <p><code><a href="#stream_writable_write_chunk_encoding_callback_1">_write</a></code></p> </td> </tr>
<tr>
<td> <p>Reading and writing</p> </td> <td> <p><a href="#stream_class_stream_duplex_1">Duplex</a></p> </td> <td> <p><code><a href="#stream_readable_read_size_1">_read</a></code>, <code><a href="#stream_writable_write_chunk_encoding_callback_1">_write</a></code></p> </td> </tr>
<tr>
<td> <p>Operate on written data, then read the result</p> </td> <td> <p><a href="#stream_class_stream_transform_1">Transform</a></p> </td> <td> <p><code>_transform</code>, <code>_flush</code></p> </td> </tr>
</tbody></table>
<p>In your implementation code, it is very important to never call the methods described in <a href="#stream_api_for_stream_consumers">API for Stream Consumers</a> above. Otherwise, you can potentially cause adverse side effects in programs that consume your streaming interfaces. </p> <h3 id="stream_class_stream_readable_1">Class: stream.Readable</h3>  <p><code>stream.Readable</code> is an abstract class designed to be extended with an underlying implementation of the <a href="#stream_readable_read_size_1"><code>_read(size)</code></a> method. </p> <p>Please see above under <a href="#stream_api_for_stream_consumers">API for Stream Consumers</a> for how to consume streams in your programs. What follows is an explanation of how to implement Readable streams in your programs. </p> <h4 id="stream_example_a_counting_stream">Example: A Counting Stream</h4>  <p>This is a basic example of a Readable stream. It emits the numerals from 1 to 1,000,000 in ascending order, and then ends. </p> <pre class=" language-javascript"><code class="javascript  language-javascript"><span class="token keyword">var</span> Readable <span class="token operator">=</span> <span class="token function">require<span class="token punctuation">(</span></span><span class="token string">'stream'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Readable<span class="token punctuation">;</span>
<span class="token keyword">var</span> util <span class="token operator">=</span> <span class="token function">require<span class="token punctuation">(</span></span><span class="token string">'util'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
util<span class="token punctuation">.</span><span class="token function">inherits<span class="token punctuation">(</span></span>Counter<span class="token punctuation">,</span> Readable<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">Counter<span class="token punctuation">(</span></span>opt<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Readable<span class="token punctuation">.</span><span class="token function">call<span class="token punctuation">(</span></span>this<span class="token punctuation">,</span> opt<span class="token punctuation">)</span><span class="token punctuation">;</span>
  this<span class="token punctuation">.</span>_max <span class="token operator">=</span> <span class="token number">1000000</span><span class="token punctuation">;</span>
  this<span class="token punctuation">.</span>_index <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

Counter<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>_read <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> i <span class="token operator">=</span> this<span class="token punctuation">.</span>_index<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> this<span class="token punctuation">.</span>_max<span class="token punctuation">)</span>
    this<span class="token punctuation">.</span><span class="token function">push<span class="token punctuation">(</span></span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">''</span> <span class="token operator">+</span> i<span class="token punctuation">;</span>
    <span class="token keyword">var</span> buf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Buffer</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token string">'ascii'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    this<span class="token punctuation">.</span><span class="token function">push<span class="token punctuation">(</span></span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre> <h4 id="stream_example_simpleprotocol_v1_sub_optimal">Example: SimpleProtocol v1 (Sub-optimal)</h4> <p>This is similar to the <code>parseHeader</code> function described above, but implemented as a custom stream. Also, note that this implementation does not convert the incoming data to a string. </p> <p>However, this would be better implemented as a <a href="#stream_class_stream_transform">Transform</a> stream. See below for a better implementation. </p> <pre class=" language-javascript"><code class="javascript  language-javascript"><span class="token comment" spellcheck="true">// A parser for a simple data protocol.
</span><span class="token comment" spellcheck="true">// The "header" is a JSON object, followed by 2 \n characters, and
</span><span class="token comment" spellcheck="true">// then a message body.
</span><span class="token comment" spellcheck="true">//
</span><span class="token comment" spellcheck="true">// NOTE: This can be done more simply as a Transform stream!
</span><span class="token comment" spellcheck="true">// Using Readable directly for this is sub-optimal.  See the
</span><span class="token comment" spellcheck="true">// alternative example below under the Transform section.
</span>
<span class="token keyword">var</span> Readable <span class="token operator">=</span> <span class="token function">require<span class="token punctuation">(</span></span><span class="token string">'stream'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Readable<span class="token punctuation">;</span>
<span class="token keyword">var</span> util <span class="token operator">=</span> <span class="token function">require<span class="token punctuation">(</span></span><span class="token string">'util'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

util<span class="token punctuation">.</span><span class="token function">inherits<span class="token punctuation">(</span></span>SimpleProtocol<span class="token punctuation">,</span> Readable<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">SimpleProtocol<span class="token punctuation">(</span></span>source<span class="token punctuation">,</span> options<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>this <span class="token keyword">instanceof</span> <span class="token class-name">SimpleProtocol</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SimpleProtocol</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>

  Readable<span class="token punctuation">.</span><span class="token function">call<span class="token punctuation">(</span></span>this<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>
  this<span class="token punctuation">.</span>_inBody <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  this<span class="token punctuation">.</span>_sawFirstCr <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

 <span class="token comment" spellcheck="true"> // source is a readable stream, such as a socket or file
</span>  this<span class="token punctuation">.</span>_source <span class="token operator">=</span> source<span class="token punctuation">;</span>

  <span class="token keyword">var</span> self <span class="token operator">=</span> this<span class="token punctuation">;</span>
  source<span class="token punctuation">.</span><span class="token function">on<span class="token punctuation">(</span></span><span class="token string">'end'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    self<span class="token punctuation">.</span><span class="token function">push<span class="token punctuation">(</span></span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token comment" spellcheck="true"> // give it a kick whenever the source is readable
</span> <span class="token comment" spellcheck="true"> // read(0) will not consume any bytes
</span>  source<span class="token punctuation">.</span><span class="token function">on<span class="token punctuation">(</span></span><span class="token string">'readable'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    self<span class="token punctuation">.</span><span class="token function">read<span class="token punctuation">(</span></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  this<span class="token punctuation">.</span>_rawHeader <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  this<span class="token punctuation">.</span>header <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

SimpleProtocol<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>_read <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>this<span class="token punctuation">.</span>_inBody<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> chunk <span class="token operator">=</span> this<span class="token punctuation">.</span>_source<span class="token punctuation">.</span><span class="token function">read<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>

   <span class="token comment" spellcheck="true"> // if the source doesn't have data, we don't have data yet.
</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>chunk <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
      <span class="token keyword">return</span> this<span class="token punctuation">.</span><span class="token function">push<span class="token punctuation">(</span></span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

   <span class="token comment" spellcheck="true"> // check if the chunk has a \n\n
</span>    <span class="token keyword">var</span> split <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> chunk<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>chunk<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true"> // '\n'
</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>this<span class="token punctuation">.</span>_sawFirstCr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          split <span class="token operator">=</span> i<span class="token punctuation">;</span>
          <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          this<span class="token punctuation">.</span>_sawFirstCr <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        this<span class="token punctuation">.</span>_sawFirstCr <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>split <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment" spellcheck="true"> // still waiting for the \n\n
</span>     <span class="token comment" spellcheck="true"> // stash the chunk, and try again.
</span>      this<span class="token punctuation">.</span>_rawHeader<span class="token punctuation">.</span><span class="token function">push<span class="token punctuation">(</span></span>chunk<span class="token punctuation">)</span><span class="token punctuation">;</span>
      this<span class="token punctuation">.</span><span class="token function">push<span class="token punctuation">(</span></span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      this<span class="token punctuation">.</span>_inBody <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      <span class="token keyword">var</span> h <span class="token operator">=</span> chunk<span class="token punctuation">.</span><span class="token function">slice<span class="token punctuation">(</span></span><span class="token number">0</span><span class="token punctuation">,</span> split<span class="token punctuation">)</span><span class="token punctuation">;</span>
      this<span class="token punctuation">.</span>_rawHeader<span class="token punctuation">.</span><span class="token function">push<span class="token punctuation">(</span></span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">var</span> header <span class="token operator">=</span> Buffer<span class="token punctuation">.</span><span class="token function">concat<span class="token punctuation">(</span></span>this<span class="token punctuation">.</span>_rawHeader<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        this<span class="token punctuation">.</span>header <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse<span class="token punctuation">(</span></span>header<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">er</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        this<span class="token punctuation">.</span><span class="token function">emit<span class="token punctuation">(</span></span><span class="token string">'error'</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'invalid simple protocol data'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
     <span class="token comment" spellcheck="true"> // now, because we got some extra data, unshift the rest
</span>     <span class="token comment" spellcheck="true"> // back into the read queue so that our consumer will see it.
</span>      <span class="token keyword">var</span> b <span class="token operator">=</span> chunk<span class="token punctuation">.</span><span class="token function">slice<span class="token punctuation">(</span></span>split<span class="token punctuation">)</span><span class="token punctuation">;</span>
      this<span class="token punctuation">.</span><span class="token function">unshift<span class="token punctuation">(</span></span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>

     <span class="token comment" spellcheck="true"> // and let them know that we are done parsing the header.
</span>      this<span class="token punctuation">.</span><span class="token function">emit<span class="token punctuation">(</span></span><span class="token string">'header'</span><span class="token punctuation">,</span> this<span class="token punctuation">.</span>header<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
   <span class="token comment" spellcheck="true"> // from there on, just provide the data to our consumer.
</span>   <span class="token comment" spellcheck="true"> // careful not to push(null), since that would indicate EOF.
</span>    <span class="token keyword">var</span> chunk <span class="token operator">=</span> this<span class="token punctuation">.</span>_source<span class="token punctuation">.</span><span class="token function">read<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>chunk<span class="token punctuation">)</span> this<span class="token punctuation">.</span><span class="token function">push<span class="token punctuation">(</span></span>chunk<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">
// Usage:
</span><span class="token comment" spellcheck="true">// var parser = new SimpleProtocol(source);
</span><span class="token comment" spellcheck="true">// Now parser is a readable stream that will emit 'header'
</span><span class="token comment" spellcheck="true">// with the parsed header data.</span></code></pre> <h4 id="stream_new_stream_readable_options">new stream.Readable([options])</h4> <div class="signature"><ul>
<li>
<code>options</code> <span class="type">Object</span><ul>
<li>
<code>highWaterMark</code> <span class="type">Number</span> The maximum number of bytes to store in the internal buffer before ceasing to read from the underlying resource. Default=16kb</li> <li>
<code>encoding</code> <span class="type">String</span> If specified, then buffers will be decoded to strings using the specified encoding. Default=null</li> <li>
<code>objectMode</code> <span class="type">Boolean</span> Whether this stream should behave as a stream of objects. Meaning that stream.read(n) returns a single value instead of a Buffer of size n. Default=false</li> </ul>
</li> </ul></div> <p>In classes that extend the Readable class, make sure to call the Readable constructor so that the buffering settings can be properly initialized. </p> <h4 id="stream_readable_read_size_1">readable._read(size)</h4> <div class="signature"><ul>
<li>
<code>size</code> <span class="type">Number</span> Number of bytes to read asynchronously</li> </ul></div> <p>Note: <strong>Implement this function, but do NOT call it directly.</strong> </p> <p>This function should NOT be called directly. It should be implemented by child classes, and only called by the internal Readable class methods. </p> <p>All Readable stream implementations must provide a <code>_read</code> method to fetch data from the underlying resource. </p> <p>This method is prefixed with an underscore because it is internal to the class that defines it, and should not be called directly by user programs. However, you <strong>are</strong> expected to override this method in your own extension classes. </p> <p>When data is available, put it into the read queue by calling <code>readable.push(chunk)</code>. If <code>push</code> returns false, then you should stop reading. When <code>_read</code> is called again, you should start pushing more data. </p> <p>The <code>size</code> argument is advisory. Implementations where a "read" is a single call that returns data can use this to know how much data to fetch. Implementations where that is not relevant, such as TCP or TLS, may ignore this argument, and simply provide data whenever it becomes available. There is no need, for example to "wait" until <code>size</code> bytes are available before calling <a href="#stream_readable_push_chunk_encoding"><code>stream.push(chunk)</code></a>. </p> <h4 id="stream_readable_push_chunk_encoding">readable.push(chunk, [encoding])</h4> <div class="signature"><ul>
<li>
<code>chunk</code> <span class="type">Buffer | null | String</span> Chunk of data to push into the read queue</li> <li>
<code>encoding</code> <span class="type">String</span> Encoding of String chunks. Must be a valid Buffer encoding, such as <code>'utf8'</code> or <code>'ascii'</code>
</li> <li>return <span class="type">Boolean</span> Whether or not more pushes should be performed</li> </ul></div> <p>Note: <strong>This function should be called by Readable implementors, NOT by consumers of Readable streams.</strong> </p> <p>The <code>_read()</code> function will not be called again until at least one <code>push(chunk)</code> call is made. </p> <p>The <code>Readable</code> class works by putting data into a read queue to be pulled out later by calling the <code>read()</code> method when the <code>'readable'</code> event fires. </p> <p>The <code>push()</code> method will explicitly insert some data into the read queue. If it is called with <code>null</code> then it will signal the end of the data (EOF). </p> <p>This API is designed to be as flexible as possible. For example, you may be wrapping a lower-level source which has some sort of pause/resume mechanism, and a data callback. In those cases, you could wrap the low-level source object by doing something like this: </p> <pre class=" language-javascript"><code class="javascript  language-javascript"><span class="token comment" spellcheck="true">// source is an object with readStop() and readStart() methods,
</span><span class="token comment" spellcheck="true">// and an `ondata` member that gets called when it has data, and
</span><span class="token comment" spellcheck="true">// an `onend` member that gets called when the data is over.
</span>
util<span class="token punctuation">.</span><span class="token function">inherits<span class="token punctuation">(</span></span>SourceWrapper<span class="token punctuation">,</span> Readable<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">SourceWrapper<span class="token punctuation">(</span></span>options<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Readable<span class="token punctuation">.</span><span class="token function">call<span class="token punctuation">(</span></span>this<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>

  this<span class="token punctuation">.</span>_source <span class="token operator">=</span> <span class="token function">getLowlevelSourceObject<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> self <span class="token operator">=</span> this<span class="token punctuation">;</span>

 <span class="token comment" spellcheck="true"> // Every time there's data, we push it into the internal buffer.
</span>  this<span class="token punctuation">.</span>_source<span class="token punctuation">.</span>ondata <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>chunk<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment" spellcheck="true"> // if push() returns false, then we need to stop reading from source
</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>self<span class="token punctuation">.</span><span class="token function">push<span class="token punctuation">(</span></span>chunk<span class="token punctuation">)</span><span class="token punctuation">)</span>
      self<span class="token punctuation">.</span>_source<span class="token punctuation">.</span><span class="token function">readStop<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

 <span class="token comment" spellcheck="true"> // When the source ends, we push the EOF-signalling `null` chunk
</span>  this<span class="token punctuation">.</span>_source<span class="token punctuation">.</span>onend <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    self<span class="token punctuation">.</span><span class="token function">push<span class="token punctuation">(</span></span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">
// _read will be called when the stream wants to pull more data in
</span><span class="token comment" spellcheck="true">// the advisory size argument is ignored in this case.
</span>SourceWrapper<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>_read <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  this<span class="token punctuation">.</span>_source<span class="token punctuation">.</span><span class="token function">readStart<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre> <h3 id="stream_class_stream_writable_1">Class: stream.Writable</h3>  <p><code>stream.Writable</code> is an abstract class designed to be extended with an underlying implementation of the <a href="#stream_writable_write_chunk_encoding_callback_1"><code>_write(chunk, encoding, callback)</code></a> method. </p> <p>Please see above under <a href="#stream_api_for_stream_consumers">API for Stream Consumers</a> for how to consume writable streams in your programs. What follows is an explanation of how to implement Writable streams in your programs. </p> <h4 id="stream_new_stream_writable_options">new stream.Writable([options])</h4> <div class="signature"><ul>
<li>
<code>options</code> <span class="type">Object</span><ul>
<li>
<code>highWaterMark</code> <span class="type">Number</span> Buffer level when <a href="#stream_writable_write_chunk_encoding_callback"><code>write()</code></a> starts returning false. Default=16kb</li> <li>
<code>decodeStrings</code> <span class="type">Boolean</span> Whether or not to decode strings into Buffers before passing them to <a href="#stream_writable_write_chunk_encoding_callback_1"><code>_write()</code></a>. Default=true</li> </ul>
</li> </ul></div> <p>In classes that extend the Writable class, make sure to call the constructor so that the buffering settings can be properly initialized. </p> <h4 id="stream_writable_write_chunk_encoding_callback_1">writable._write(chunk, encoding, callback)</h4> <div class="signature"><ul>
<li>
<code>chunk</code> <span class="type">Buffer | String</span> The chunk to be written. Will always be a buffer unless the <code>decodeStrings</code> option was set to <code>false</code>.</li> <li>
<code>encoding</code> <span class="type">String</span> If the chunk is a string, then this is the encoding type. Ignore chunk is a buffer. Note that chunk will <strong>always</strong> be a buffer unless the <code>decodeStrings</code> option is explicitly set to <code>false</code>.</li> <li>
<code>callback</code> <span class="type">Function</span> Call this function (optionally with an error argument) when you are done processing the supplied chunk.</li> </ul></div> <p>All Writable stream implementations must provide a <a href="#stream_writable_write_chunk_encoding_callback_1"><code>_write()</code></a> method to send data to the underlying resource. </p> <p>Note: <strong>This function MUST NOT be called directly.</strong> It should be implemented by child classes, and called by the internal Writable class methods only. </p> <p>Call the callback using the standard <code>callback(error)</code> pattern to signal that the write completed successfully or with an error. </p> <p>If the <code>decodeStrings</code> flag is set in the constructor options, then <code>chunk</code> may be a string rather than a Buffer, and <code>encoding</code> will indicate the sort of string that it is. This is to support implementations that have an optimized handling for certain string data encodings. If you do not explicitly set the <code>decodeStrings</code> option to <code>false</code>, then you can safely ignore the <code>encoding</code> argument, and assume that <code>chunk</code> will always be a Buffer. </p> <p>This method is prefixed with an underscore because it is internal to the class that defines it, and should not be called directly by user programs. However, you <strong>are</strong> expected to override this method in your own extension classes. </p> <h3 id="stream_class_stream_duplex_1">Class: stream.Duplex</h3>  <p>A "duplex" stream is one that is both Readable and Writable, such as a TCP socket connection. </p> <p>Note that <code>stream.Duplex</code> is an abstract class designed to be extended with an underlying implementation of the <code>_read(size)</code> and <a href="#stream_writable_write_chunk_encoding_callback_1"><code>_write(chunk, encoding, callback)</code></a> methods as you would with a Readable or Writable stream class. </p> <p>Since JavaScript doesn't have multiple prototypal inheritance, this class prototypally inherits from Readable, and then parasitically from Writable. It is thus up to the user to implement both the lowlevel <code>_read(n)</code> method as well as the lowlevel <a href="#stream_writable_write_chunk_encoding_callback_1"><code>_write(chunk, encoding, callback)</code></a> method on extension duplex classes. </p> <h4 id="stream_new_stream_duplex_options">new stream.Duplex(options)</h4> <div class="signature"><ul>
<li>
<code>options</code> <span class="type">Object</span> Passed to both Writable and Readable constructors. Also has the following fields:<ul>
<li>
<code>allowHalfOpen</code> <span class="type">Boolean</span> Default=true. If set to <code>false</code>, then the stream will automatically end the readable side when the writable side ends and vice versa.</li> </ul>
</li> </ul></div> <p>In classes that extend the Duplex class, make sure to call the constructor so that the buffering settings can be properly initialized. </p> <h3 id="stream_class_stream_transform_1">Class: stream.Transform</h3> <p>A "transform" stream is a duplex stream where the output is causally connected in some way to the input, such as a <a href="zlib">zlib</a> stream or a <a href="crypto">crypto</a> stream. </p> <p>There is no requirement that the output be the same size as the input, the same number of chunks, or arrive at the same time. For example, a Hash stream will only ever have a single chunk of output which is provided when the input is ended. A zlib stream will produce output that is either much smaller or much larger than its input. </p> <p>Rather than implement the <a href="#stream_readable_read_size_1"><code>_read()</code></a> and <a href="#stream_writable_write_chunk_encoding_callback_1"><code>_write()</code></a> methods, Transform classes must implement the <code>_transform()</code> method, and may optionally also implement the <code>_flush()</code> method. (See below.) </p> <h4 id="stream_new_stream_transform_options">new stream.Transform([options])</h4> <div class="signature"><ul>
<li>
<code>options</code> <span class="type">Object</span> Passed to both Writable and Readable constructors.</li> </ul></div> <p>In classes that extend the Transform class, make sure to call the constructor so that the buffering settings can be properly initialized. </p> <h4 id="stream_transform_transform_chunk_encoding_callback">transform._transform(chunk, encoding, callback)</h4> <div class="signature"><ul>
<li>
<code>chunk</code> <span class="type">Buffer | String</span> The chunk to be transformed. Will always be a buffer unless the <code>decodeStrings</code> option was set to <code>false</code>.</li> <li>
<code>encoding</code> <span class="type">String</span> If the chunk is a string, then this is the encoding type. (Ignore if <code>decodeStrings</code> chunk is a buffer.)</li> <li>
<code>callback</code> <span class="type">Function</span> Call this function (optionally with an error argument) when you are done processing the supplied chunk.</li> </ul></div> <p>Note: <strong>This function MUST NOT be called directly.</strong> It should be implemented by child classes, and called by the internal Transform class methods only. </p> <p>All Transform stream implementations must provide a <code>_transform</code> method to accept input and produce output. </p> <p><code>_transform</code> should do whatever has to be done in this specific Transform class, to handle the bytes being written, and pass them off to the readable portion of the interface. Do asynchronous I/O, process things, and so on. </p> <p>Call <code>transform.push(outputChunk)</code> 0 or more times to generate output from this input chunk, depending on how much data you want to output as a result of this chunk. </p> <p>Call the callback function only when the current chunk is completely consumed. Note that there may or may not be output as a result of any particular input chunk. </p> <p>This method is prefixed with an underscore because it is internal to the class that defines it, and should not be called directly by user programs. However, you <strong>are</strong> expected to override this method in your own extension classes. </p> <h4 id="stream_transform_flush_callback">transform._flush(callback)</h4> <div class="signature"><ul>
<li>
<code>callback</code> <span class="type">Function</span> Call this function (optionally with an error argument) when you are done flushing any remaining data.</li> </ul></div> <p>Note: <strong>This function MUST NOT be called directly.</strong> It MAY be implemented by child classes, and if so, will be called by the internal Transform class methods only. </p> <p>In some cases, your transform operation may need to emit a bit more data at the end of the stream. For example, a <code>Zlib</code> compression stream will store up some internal state so that it can optimally compress the output. At the end, however, it needs to do the best it can with what is left, so that the data will be complete. </p> <p>In those cases, you can implement a <code>_flush</code> method, which will be called at the very end, after all the written data is consumed, but before emitting <code>end</code> to signal the end of the readable side. Just like with <code>_transform</code>, call <code>transform.push(chunk)</code> zero or more times, as appropriate, and call <code>callback</code> when the flush operation is complete. </p> <p>This method is prefixed with an underscore because it is internal to the class that defines it, and should not be called directly by user programs. However, you <strong>are</strong> expected to override this method in your own extension classes. </p> <h4 id="stream_example_simpleprotocol_parser_v2">Example: <code>SimpleProtocol</code> parser v2</h4> <p>The example above of a simple protocol parser can be implemented simply by using the higher level <a href="#stream_class_stream_transform">Transform</a> stream class, similar to the <code>parseHeader</code> and <code>SimpleProtocol v1</code> examples above. </p> <p>In this example, rather than providing the input as an argument, it would be piped into the parser, which is a more idiomatic Node stream approach. </p> <pre class=" language-javascript"><code class="javascript  language-javascript"><span class="token keyword">var</span> util <span class="token operator">=</span> <span class="token function">require<span class="token punctuation">(</span></span><span class="token string">'util'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> Transform <span class="token operator">=</span> <span class="token function">require<span class="token punctuation">(</span></span><span class="token string">'stream'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Transform<span class="token punctuation">;</span>
util<span class="token punctuation">.</span><span class="token function">inherits<span class="token punctuation">(</span></span>SimpleProtocol<span class="token punctuation">,</span> Transform<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">SimpleProtocol<span class="token punctuation">(</span></span>options<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>this <span class="token keyword">instanceof</span> <span class="token class-name">SimpleProtocol</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SimpleProtocol</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>

  Transform<span class="token punctuation">.</span><span class="token function">call<span class="token punctuation">(</span></span>this<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>
  this<span class="token punctuation">.</span>_inBody <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  this<span class="token punctuation">.</span>_sawFirstCr <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  this<span class="token punctuation">.</span>_rawHeader <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  this<span class="token punctuation">.</span>header <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

SimpleProtocol<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>_transform <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>chunk<span class="token punctuation">,</span> encoding<span class="token punctuation">,</span> done<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>this<span class="token punctuation">.</span>_inBody<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment" spellcheck="true"> // check if the chunk has a \n\n
</span>    <span class="token keyword">var</span> split <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> chunk<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>chunk<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true"> // '\n'
</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>this<span class="token punctuation">.</span>_sawFirstCr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          split <span class="token operator">=</span> i<span class="token punctuation">;</span>
          <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          this<span class="token punctuation">.</span>_sawFirstCr <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        this<span class="token punctuation">.</span>_sawFirstCr <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>split <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment" spellcheck="true"> // still waiting for the \n\n
</span>     <span class="token comment" spellcheck="true"> // stash the chunk, and try again.
</span>      this<span class="token punctuation">.</span>_rawHeader<span class="token punctuation">.</span><span class="token function">push<span class="token punctuation">(</span></span>chunk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      this<span class="token punctuation">.</span>_inBody <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      <span class="token keyword">var</span> h <span class="token operator">=</span> chunk<span class="token punctuation">.</span><span class="token function">slice<span class="token punctuation">(</span></span><span class="token number">0</span><span class="token punctuation">,</span> split<span class="token punctuation">)</span><span class="token punctuation">;</span>
      this<span class="token punctuation">.</span>_rawHeader<span class="token punctuation">.</span><span class="token function">push<span class="token punctuation">(</span></span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">var</span> header <span class="token operator">=</span> Buffer<span class="token punctuation">.</span><span class="token function">concat<span class="token punctuation">(</span></span>this<span class="token punctuation">.</span>_rawHeader<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        this<span class="token punctuation">.</span>header <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse<span class="token punctuation">(</span></span>header<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">er</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        this<span class="token punctuation">.</span><span class="token function">emit<span class="token punctuation">(</span></span><span class="token string">'error'</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'invalid simple protocol data'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
     <span class="token comment" spellcheck="true"> // and let them know that we are done parsing the header.
</span>      this<span class="token punctuation">.</span><span class="token function">emit<span class="token punctuation">(</span></span><span class="token string">'header'</span><span class="token punctuation">,</span> this<span class="token punctuation">.</span>header<span class="token punctuation">)</span><span class="token punctuation">;</span>

     <span class="token comment" spellcheck="true"> // now, because we got some extra data, emit this first.
</span>      this<span class="token punctuation">.</span><span class="token function">push<span class="token punctuation">(</span></span>chunk<span class="token punctuation">.</span><span class="token function">slice<span class="token punctuation">(</span></span>split<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
   <span class="token comment" spellcheck="true"> // from there on, just provide the data to our consumer as-is.
</span>    this<span class="token punctuation">.</span><span class="token function">push<span class="token punctuation">(</span></span>chunk<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">done<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">
// Usage:
</span><span class="token comment" spellcheck="true">// var parser = new SimpleProtocol();
</span><span class="token comment" spellcheck="true">// source.pipe(parser)
</span><span class="token comment" spellcheck="true">// Now parser is a readable stream that will emit 'header'
</span><span class="token comment" spellcheck="true">// with the parsed header data.</span></code></pre> <h3 id="stream_class_stream_passthrough">Class: stream.PassThrough</h3> <p>This is a trivial implementation of a <a href="#stream_class_stream_transform">Transform</a> stream that simply passes the input bytes across to the output. Its purpose is mainly for examples and testing, but there are occasionally use cases where it can come in handy as a building block for novel sorts of streams. </p> <h2 id="stream_streams_under_the_hood">Streams: Under the Hood</h2>  <h3 id="stream_buffering">Buffering</h3>  <p>Both Writable and Readable streams will buffer data on an internal object called <code>_writableState.buffer</code> or <code>_readableState.buffer</code>, respectively. </p> <p>The amount of data that will potentially be buffered depends on the <code>highWaterMark</code> option which is passed into the constructor. </p> <p>Buffering in Readable streams happens when the implementation calls <a href="#stream_readable_push_chunk_encoding"><code>stream.push(chunk)</code></a>. If the consumer of the Stream does not call <code>stream.read()</code>, then the data will sit in the internal queue until it is consumed. </p> <p>Buffering in Writable streams happens when the user calls <a href="#stream_writable_write_chunk_encoding_callback"><code>stream.write(chunk)</code></a> repeatedly, even when <code>write()</code> returns <code>false</code>. </p> <p>The purpose of streams, especially with the <code>pipe()</code> method, is to limit the buffering of data to acceptable levels, so that sources and destinations of varying speed will not overwhelm the available memory. </p> <h3 id="stream_stream_read_0"><code>stream.read(0)</code></h3> <p>There are some cases where you want to trigger a refresh of the underlying readable stream mechanisms, without actually consuming any data. In that case, you can call <code>stream.read(0)</code>, which will always return null. </p> <p>If the internal read buffer is below the <code>highWaterMark</code>, and the stream is not currently reading, then calling <code>read(0)</code> will trigger a low-level <code>_read</code> call. </p> <p>There is almost never a need to do this. However, you will see some cases in Node's internals where this is done, particularly in the Readable stream class internals. </p> <h3 id="stream_stream_push"><code>stream.push('')</code></h3> <p>Pushing a zero-byte string or Buffer (when not in <a href="#stream_object_mode">Object mode</a>) has an interesting side effect. Because it <em>is</em> a call to <a href="#stream_readable_push_chunk_encoding"><code>stream.push()</code></a>, it will end the <code>reading</code> process. However, it does <em>not</em> add any data to the readable buffer, so there's nothing for a user to consume. </p> <p>Very rarely, there are cases where you have no data to provide now, but the consumer of your stream (or, perhaps, another bit of your own code) will know when to check again, by calling <code>stream.read(0)</code>. In those cases, you <em>may</em> call <code>stream.push('')</code>. </p> <p>So far, the only use case for this functionality is in the <a href="tls#tls_class_cryptostream">tls.CryptoStream</a> class, which is deprecated in Node v0.12. If you find that you have to use <code>stream.push('')</code>, please consider another approach, because it almost certainly indicates that something is horribly wrong. </p> <h3 id="stream_compatibility_with_older_node_versions">Compatibility with Older Node Versions</h3>  <p>In versions of Node prior to v0.10, the Readable stream interface was simpler, but also less powerful and less useful. </p> <ul>
<li>Rather than waiting for you to call the <code>read()</code> method, <code>'data'</code> events would start emitting immediately. If you needed to do some I/O to decide how to handle data, then you had to store the chunks in some kind of buffer so that they would not be lost.</li> <li>The <code>pause()</code> method was advisory, rather than guaranteed. This meant that you still had to be prepared to receive <code>'data'</code> events even when the stream was in a paused state.</li> </ul>
<p>In Node v0.10, the Readable class described below was added. For backwards compatibility with older Node programs, Readable streams switch into "flowing mode" when a <code>'data'</code> event handler is added, or when the <code>pause()</code> or <code>resume()</code> methods are called. The effect is that, even if you are not using the new <code>read()</code> method and <code>'readable'</code> event, you no longer have to worry about losing <code>'data'</code> chunks. </p> <p>Most programs will continue to function normally. However, this introduces an edge case in the following conditions: </p> <ul>
<li>No <code>'data'</code> event handler is added.</li> <li>The <code>pause()</code> and <code>resume()</code> methods are never called.</li> </ul>
<p>For example, consider the following code: </p> <pre class=" language-javascript"><code class="javascript  language-javascript"><span class="token comment" spellcheck="true">// WARNING!  BROKEN!
</span>net<span class="token punctuation">.</span><span class="token function">createServer<span class="token punctuation">(</span></span><span class="token keyword">function</span><span class="token punctuation">(</span>socket<span class="token punctuation">)</span> <span class="token punctuation">{</span>

 <span class="token comment" spellcheck="true"> // we add an 'end' method, but never consume the data
</span>  socket<span class="token punctuation">.</span><span class="token function">on<span class="token punctuation">(</span></span><span class="token string">'end'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment" spellcheck="true"> // It will never get here.
</span>    socket<span class="token punctuation">.</span><span class="token function">end<span class="token punctuation">(</span></span><span class="token string">'I got your message (but didnt read it)\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen<span class="token punctuation">(</span></span><span class="token number">1337</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> <p>In versions of node prior to v0.10, the incoming message data would be simply discarded. However, in Node v0.10 and beyond, the socket will remain paused forever. </p> <p>The workaround in this situation is to call the <code>resume()</code> method to trigger "old mode" behavior: </p> <pre class=" language-javascript"><code class="javascript  language-javascript"><span class="token comment" spellcheck="true">// Workaround
</span>net<span class="token punctuation">.</span><span class="token function">createServer<span class="token punctuation">(</span></span><span class="token keyword">function</span><span class="token punctuation">(</span>socket<span class="token punctuation">)</span> <span class="token punctuation">{</span>

  socket<span class="token punctuation">.</span><span class="token function">on<span class="token punctuation">(</span></span><span class="token string">'end'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    socket<span class="token punctuation">.</span><span class="token function">end<span class="token punctuation">(</span></span><span class="token string">'I got your message (but didnt read it)\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token comment" spellcheck="true"> // start the flow of data, discarding it.
</span>  socket<span class="token punctuation">.</span><span class="token function">resume<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen<span class="token punctuation">(</span></span><span class="token number">1337</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> <p>In addition to new Readable streams switching into flowing-mode, pre-v0.10 style streams can be wrapped in a Readable class using the <code>wrap()</code> method. </p> <h3 id="stream_object_mode">Object Mode</h3>  <p>Normally, Streams operate on Strings and Buffers exclusively. </p> <p>Streams that are in <strong>object mode</strong> can emit generic JavaScript values other than Buffers and Strings. </p> <p>A Readable stream in object mode will always return a single item from a call to <code>stream.read(size)</code>, regardless of what the size argument is. </p> <p>A Writable stream in object mode will always ignore the <code>encoding</code> argument to <code>stream.write(data, encoding)</code>. </p> <p>The special value <code>null</code> still retains its special value for object mode streams. That is, for object mode readable streams, <code>null</code> as a return value from <code>stream.read()</code> indicates that there is no more data, and <a href="#stream_readable_push_chunk_encoding"><code>stream.push(null)</code></a> will signal the end of stream data (<code>EOF</code>). </p> <p>No streams in Node core are object mode streams. This pattern is only used by userland streaming libraries. </p> <p>You should set <code>objectMode</code> in your stream child class constructor on the options object. Setting <code>objectMode</code> mid-stream is not safe. </p> <h3 id="stream_state_objects">State Objects</h3> <p><a href="#stream_class_stream_readable">Readable</a> streams have a member object called <code>_readableState</code>. <a href="#stream_class_stream_writable">Writable</a> streams have a member object called <code>_writableState</code>. <a href="#stream_class_stream_duplex">Duplex</a> streams have both. </p> <p><strong>These objects should generally not be modified in child classes.</strong> However, if you have a Duplex or Transform stream that should be in <code>objectMode</code> on the readable side, and not in <code>objectMode</code> on the writable side, then you may do this in the constructor by setting the flag explicitly on the appropriate state object. </p> <pre class=" language-javascript"><code class="javascript  language-javascript"><span class="token keyword">var</span> util <span class="token operator">=</span> <span class="token function">require<span class="token punctuation">(</span></span><span class="token string">'util'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> StringDecoder <span class="token operator">=</span> <span class="token function">require<span class="token punctuation">(</span></span><span class="token string">'string_decoder'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>StringDecoder<span class="token punctuation">;</span>
<span class="token keyword">var</span> Transform <span class="token operator">=</span> <span class="token function">require<span class="token punctuation">(</span></span><span class="token string">'stream'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Transform<span class="token punctuation">;</span>
util<span class="token punctuation">.</span><span class="token function">inherits<span class="token punctuation">(</span></span>JSONParseStream<span class="token punctuation">,</span> Transform<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">
// Gets \n-delimited JSON string data, and emits the parsed objects
</span><span class="token keyword">function</span> <span class="token function">JSONParseStream<span class="token punctuation">(</span></span>options<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>this <span class="token keyword">instanceof</span> <span class="token class-name">JSONParseStream</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">JSONParseStream</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>

  Transform<span class="token punctuation">.</span><span class="token function">call<span class="token punctuation">(</span></span>this<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>
  this<span class="token punctuation">.</span>_writableState<span class="token punctuation">.</span>objectMode <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  this<span class="token punctuation">.</span>_readableState<span class="token punctuation">.</span>objectMode <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  this<span class="token punctuation">.</span>_buffer <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>
  this<span class="token punctuation">.</span>_decoder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringDecoder</span><span class="token punctuation">(</span><span class="token string">'utf8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

JSONParseStream<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>_transform <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>chunk<span class="token punctuation">,</span> encoding<span class="token punctuation">,</span> cb<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  this<span class="token punctuation">.</span>_buffer <span class="token operator">+</span><span class="token operator">=</span> this<span class="token punctuation">.</span>_decoder<span class="token punctuation">.</span><span class="token function">write<span class="token punctuation">(</span></span>chunk<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment" spellcheck="true"> // split on newlines
</span>  <span class="token keyword">var</span> lines <span class="token operator">=</span> this<span class="token punctuation">.</span>_buffer<span class="token punctuation">.</span><span class="token function">split<span class="token punctuation">(</span></span><span class="token regex">/\r?\n/</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment" spellcheck="true"> // keep the last partial line buffered
</span>  this<span class="token punctuation">.</span>_buffer <span class="token operator">=</span> lines<span class="token punctuation">.</span><span class="token function">pop<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">&lt;</span> lines<span class="token punctuation">.</span>length<span class="token punctuation">;</span> l<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> line <span class="token operator">=</span> lines<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> obj <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse<span class="token punctuation">(</span></span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">er</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      this<span class="token punctuation">.</span><span class="token function">emit<span class="token punctuation">(</span></span><span class="token string">'error'</span><span class="token punctuation">,</span> er<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
   <span class="token comment" spellcheck="true"> // push the parsed object out to the readable consumer
</span>    this<span class="token punctuation">.</span><span class="token function">push<span class="token punctuation">(</span></span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">cb<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

JSONParseStream<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>_flush <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>cb<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token comment" spellcheck="true"> // Just handle any leftover
</span>  <span class="token keyword">var</span> rem <span class="token operator">=</span> this<span class="token punctuation">.</span>_buffer<span class="token punctuation">.</span><span class="token function">trim<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>rem<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> obj <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse<span class="token punctuation">(</span></span>rem<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">er</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      this<span class="token punctuation">.</span><span class="token function">emit<span class="token punctuation">(</span></span><span class="token string">'error'</span><span class="token punctuation">,</span> er<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
   <span class="token comment" spellcheck="true"> // push the parsed object out to the readable consumer
</span>    this<span class="token punctuation">.</span><span class="token function">push<span class="token punctuation">(</span></span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">cb<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre> <p>The state objects contain other useful information for debugging the state of streams in your programs. It is safe to look at them, but beyond setting option flags in the constructor, it is <strong>not</strong> safe to modify them. </p><div class="_attribution">
  <p class="_attribution-p">
     Joyent, Inc. and other Node contributors<br>Licensed under the MIT License.<br>
    <a href="http://nodejs.org/api/stream.html" class="_attribution-link">http://nodejs.org/api/stream.html</a>
  </p>
</div>
</div>